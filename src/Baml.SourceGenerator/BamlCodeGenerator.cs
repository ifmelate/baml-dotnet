using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Baml.SourceGenerator
{
    /// <summary>
    /// Generates C# code from BAML schemas.
    /// </summary>
    public class BamlCodeGenerator
    {
        public Dictionary<string, string> Generate(List<BamlSchema> schemas)
        {
            var result = new Dictionary<string, string>();

            // Generate types (classes and enums)
            var typesCode = GenerateTypes(schemas);
            if (!string.IsNullOrEmpty(typesCode))
            {
                result["BamlTypes.g.cs"] = typesCode;
            }

            // Generate client interface and implementation
            var clientCode = GenerateClient(schemas);
            if (!string.IsNullOrEmpty(clientCode))
            {
                result["BamlClient.g.cs"] = clientCode;
            }

            return result;
        }

        private string GenerateTypes(List<BamlSchema> schemas)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine();
            sb.AppendLine("namespace Baml.Generated");
            sb.AppendLine("{");

            // Generate classes
            foreach (var schema in schemas)
            {
                foreach (var bamlClass in schema.Classes)
                {
                    GenerateClass(sb, bamlClass, schema.FilePath);
                }

                foreach (var bamlEnum in schema.Enums)
                {
                    GenerateEnum(sb, bamlEnum, schema.FilePath);
                }
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private void GenerateClass(StringBuilder sb, BamlClass bamlClass, string sourceFile)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated from BAML class '{bamlClass.Name}'.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Baml.Runtime.BamlGenerated(\"{sourceFile}\")]");
            sb.AppendLine($"    public partial class {bamlClass.Name}");
            sb.AppendLine("    {");

            foreach (var property in bamlClass.Properties)
            {
                if (!string.IsNullOrEmpty(property.Description))
                {
                    sb.AppendLine($"        /// <summary>");
                    sb.AppendLine($"        /// {property.Description}");
                    sb.AppendLine($"        /// </summary>");
                }

                var csharpType = MapBamlTypeToCSharp(property.Type);
                var propertyName = ToPascalCase(property.Name);
                var jsonPropertyName = property.Name;

                sb.AppendLine($"        [JsonPropertyName(\"{jsonPropertyName}\")]");
                sb.AppendLine($"        public {csharpType} {propertyName} {{ get; set; }}");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private void GenerateEnum(StringBuilder sb, BamlEnum bamlEnum, string sourceFile)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated from BAML enum '{bamlEnum.Name}'.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Baml.Runtime.BamlGenerated(\"{sourceFile}\")]");
            sb.AppendLine($"    public enum {bamlEnum.Name}");
            sb.AppendLine("    {");

            for (int i = 0; i < bamlEnum.Values.Count; i++)
            {
                var value = bamlEnum.Values[i];
                var enumMember = ToPascalCase(value);
                
                sb.AppendLine($"        [JsonPropertyName(\"{value}\")]");
                sb.Append($"        {enumMember}");
                
                if (i < bamlEnum.Values.Count - 1)
                    sb.Append(",");
                
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private string GenerateClient(List<BamlSchema> schemas)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Baml.Runtime;");
            sb.AppendLine("using Baml.Generated;");
            sb.AppendLine();
            sb.AppendLine("namespace Baml.Generated");
            sb.AppendLine("{");

            // Generate client interface
            GenerateClientInterface(sb, schemas);
            
            // Generate client implementation
            GenerateClientImplementation(sb, schemas);

            sb.AppendLine("}");
            return sb.ToString();
        }

        private void GenerateClientInterface(StringBuilder sb, List<BamlSchema> schemas)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated BAML client interface.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public interface IBamlGeneratedClient : IBamlClient");
            sb.AppendLine("    {");

            foreach (var schema in schemas)
            {
                foreach (var function in schema.Functions)
                {
                    GenerateFunctionSignature(sb, function, false);
                    GenerateStreamingFunctionSignature(sb, function);
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private void GenerateClientImplementation(StringBuilder sb, List<BamlSchema> schemas)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated BAML client implementation.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public partial class BamlGeneratedClient : IBamlGeneratedClient");
            sb.AppendLine("    {");
            sb.AppendLine("        public IBamlRuntime Runtime { get; }");
            sb.AppendLine();
            sb.AppendLine("        public BamlGeneratedClient(IBamlRuntime runtime)");
            sb.AppendLine("        {");
            sb.AppendLine("            Runtime = runtime ?? throw new ArgumentNullException(nameof(runtime));");
            sb.AppendLine("        }");
            sb.AppendLine();

            foreach (var schema in schemas)
            {
                foreach (var function in schema.Functions)
                {
                    GenerateFunctionImplementation(sb, function);
                    GenerateStreamingFunctionImplementation(sb, function);
                }
            }

            sb.AppendLine("    }");
        }

        private void GenerateFunctionSignature(StringBuilder sb, BamlFunction function, bool isImplementation)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);
            
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Calls the BAML function '{function.Name}'.");
            sb.AppendLine($"        /// </summary>");
            
            foreach (var param in function.Parameters)
            {
                sb.AppendLine($"        /// <param name=\"{param.Name}\">The {param.Name} parameter.</param>");
            }
            
            sb.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token for the operation.</param>");
            sb.AppendLine($"        /// <returns>The result of the function call.</returns>");
            sb.AppendLine($"        [BamlFunction(\"{function.Name}\", \"{function.Client}\")]");
            
            var parameters = string.Join(", ", function.Parameters.Select(p => 
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));
            
            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";
            
            parameters += "CancellationToken cancellationToken = default";
            
            var signature = $"Task<{returnType}> {methodName}Async({parameters})";
            
            if (isImplementation)
            {
                sb.AppendLine($"        public async {signature}");
            }
            else
            {
                sb.AppendLine($"        {signature};");
            }
        }

        private void GenerateStreamingFunctionSignature(StringBuilder sb, BamlFunction function)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);
            
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Streams the BAML function '{function.Name}'.");
            sb.AppendLine($"        /// </summary>");
            
            foreach (var param in function.Parameters)
            {
                sb.AppendLine($"        /// <param name=\"{param.Name}\">The {param.Name} parameter.</param>");
            }
            
            sb.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token for the operation.</param>");
            sb.AppendLine($"        /// <returns>An async enumerable of partial results.</returns>");
            
            var parameters = string.Join(", ", function.Parameters.Select(p => 
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));
            
            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";
            
            parameters += "CancellationToken cancellationToken = default";
            
            sb.AppendLine($"        IAsyncEnumerable<{returnType}> Stream{methodName}Async({parameters});");
            sb.AppendLine();
        }

        private void GenerateFunctionImplementation(StringBuilder sb, BamlFunction function)
        {
            GenerateFunctionSignature(sb, function, true);
            sb.AppendLine("        {");
            
            var parametersObject = "new { " + string.Join(", ", function.Parameters.Select(p => p.Name)) + " }";
            if (!function.Parameters.Any())
                parametersObject = "new { }";
            
            sb.AppendLine($"            return await Runtime.CallFunctionAsync<{MapBamlTypeToCSharp(function.ReturnType)}>(\"{function.Name}\", {parametersObject}, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateStreamingFunctionImplementation(StringBuilder sb, BamlFunction function)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);
            
            var parameters = string.Join(", ", function.Parameters.Select(p => 
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));
            
            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";
            
            parameters += "CancellationToken cancellationToken = default";
            
            sb.AppendLine($"        public IAsyncEnumerable<{returnType}> Stream{methodName}Async({parameters})");
            sb.AppendLine("        {");
            
            var parametersObject = "new { " + string.Join(", ", function.Parameters.Select(p => p.Name)) + " }";
            if (!function.Parameters.Any())
                parametersObject = "new { }";
            
            sb.AppendLine($"            return Runtime.StreamFunctionAsync<{returnType}>(\"{function.Name}\", {parametersObject}, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private string MapBamlTypeToCSharp(string bamlType)
        {
            // Handle array types
            if (bamlType.EndsWith("[]"))
            {
                var elementType = bamlType.Substring(0, bamlType.Length - 2);
                return $"IEnumerable<{MapBamlTypeToCSharp(elementType)}>";
            }

            // Handle union types (e.g., "StopTool | ReplyTool")
            if (bamlType.Contains("|"))
            {
                // For now, use object for union types
                // In a more sophisticated implementation, we could generate discriminated unions
                return "object";
            }

            // Map primitive types
            return bamlType.ToLowerInvariant() switch
            {
                "string" => "string",
                "int" => "int",
                "float" => "float",
                "double" => "double",
                "bool" => "bool",
                "boolean" => "bool",
                _ => bamlType // Assume it's a custom type
            };
        }

        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            return char.ToUpperInvariant(input[0]) + input.Substring(1);
        }
    }
}

