/*
Copyright (c) 2025 ifmelate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Baml.SourceGenerator
{
    /// <summary>
    /// Generates C# code from BAML schemas.
    /// </summary>
    public class BamlCodeGenerator
    {
        private readonly string _namespace;
        private readonly string _typeSuffix;

        public BamlCodeGenerator(string namespaceName = "Baml.Generated", string typeSuffix = "")
        {
            _namespace = namespaceName;
            _typeSuffix = typeSuffix;
        }

        public Dictionary<string, string> Generate(List<BamlSchema> schemas)
        {
            var result = new Dictionary<string, string>();

            // Attributes are now defined in Baml.Runtime project, no need to generate them

            if (schemas == null || schemas.Count == 0)
            {
                return result;
            }

            // Generate types (classes and enums)
            var typesCode = GenerateTypes(schemas);
            if (!string.IsNullOrEmpty(typesCode))
            {
                result["BamlTypes.g.cs"] = typesCode;
            }

            // Generate client interface and implementation
            var clientCode = GenerateClient(schemas);
            if (!string.IsNullOrEmpty(clientCode))
            {
                result["BamlClient.g.cs"] = clientCode;
            }

            return result;
        }

        private string GenerateTypes(List<BamlSchema> schemas)
        {
            // If there are no types across all schemas, do not generate a file
            if (!schemas.Any(s => s.Classes.Any() || s.Enums.Any()))
            {
                return string.Empty;
            }

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine();
            sb.AppendLine($"namespace {_namespace}");
            sb.AppendLine("{");

            // Generate classes
            foreach (var schema in schemas)
            {
                foreach (var bamlClass in schema.Classes)
                {
                    GenerateClass(sb, bamlClass, schema.FilePath);
                }

                foreach (var bamlEnum in schema.Enums)
                {
                    GenerateEnum(sb, bamlEnum, schema.FilePath);
                }
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private void GenerateClass(StringBuilder sb, BamlClass bamlClass, string sourceFile)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated from BAML class '{bamlClass.Name}'.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Baml.Runtime.BamlGenerated(\"{sourceFile}\")]");
            sb.AppendLine($"    public partial class {bamlClass.Name}");
            sb.AppendLine("    {");

            foreach (var property in bamlClass.Properties)
            {
                if (!string.IsNullOrEmpty(property.Description))
                {
                    sb.AppendLine($"        /// <summary>");
                    sb.AppendLine($"        /// {property.Description}");
                    sb.AppendLine($"        /// </summary>");
                }

                var csharpType = MapBamlTypeToCSharp(property.Type);
                var propertyName = ToPascalCase(property.Name);
                var jsonPropertyName = property.Name;

                sb.AppendLine($"        [JsonPropertyName(\"{jsonPropertyName}\")]");
                sb.AppendLine($"        public {csharpType} {propertyName} {{ get; set; }}");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private void GenerateEnum(StringBuilder sb, BamlEnum bamlEnum, string sourceFile)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated from BAML enum '{bamlEnum.Name}'.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Baml.Runtime.BamlGenerated(\"{sourceFile}\")]");
            sb.AppendLine($"    public enum {bamlEnum.Name}");
            sb.AppendLine("    {");

            for (int i = 0; i < bamlEnum.Values.Count; i++)
            {
                var value = bamlEnum.Values[i];
                var enumMember = ToPascalCase(value);

                sb.AppendLine($"        [JsonPropertyName(\"{value}\")]");
                sb.Append($"        {enumMember}");

                if (i < bamlEnum.Values.Count - 1)
                    sb.Append(",");

                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private string GenerateClient(List<BamlSchema> schemas)
        {
            // If there are no functions across all schemas, do not generate a client
            if (!schemas.Any(s => s.Functions.Any()))
            {
                return string.Empty;
            }

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Baml.Runtime;");
            sb.AppendLine($"using {_namespace};");
            sb.AppendLine();
            sb.AppendLine($"namespace {_namespace}");
            sb.AppendLine("{");

            // Generate client interface
            GenerateClientInterface(sb, schemas);

            // Generate client implementation
            GenerateClientImplementation(sb, schemas);

            sb.AppendLine("}");
            return sb.ToString();
        }

        private void GenerateClientInterface(StringBuilder sb, List<BamlSchema> schemas)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated BAML client interface.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public interface IBamlGeneratedClient : IBamlClient");
            sb.AppendLine("    {");

            foreach (var schema in schemas)
            {
                foreach (var function in schema.Functions)
                {
                    GenerateFunctionSignature(sb, function, false);
                    GenerateStreamingFunctionSignature(sb, function);
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private void GenerateClientImplementation(StringBuilder sb, List<BamlSchema> schemas)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated BAML client implementation.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public partial class BamlGeneratedClient : IBamlGeneratedClient");
            sb.AppendLine("    {");
            sb.AppendLine("        public IBamlRuntime Runtime { get; }");
            sb.AppendLine();
            sb.AppendLine("        public BamlGeneratedClient(IBamlRuntime runtime)");
            sb.AppendLine("        {");
            sb.AppendLine("            Runtime = runtime ?? throw new ArgumentNullException(nameof(runtime));");
            sb.AppendLine("        }");
            sb.AppendLine();

            foreach (var schema in schemas)
            {
                foreach (var function in schema.Functions)
                {
                    GenerateFunctionImplementation(sb, function);
                    GenerateStreamingFunctionImplementation(sb, function);
                }
            }

            sb.AppendLine("    }");
        }

        private void GenerateFunctionSignature(StringBuilder sb, BamlFunction function, bool isImplementation)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Calls the BAML function '{function.Name}'.");
            sb.AppendLine($"        /// </summary>");

            foreach (var param in function.Parameters)
            {
                sb.AppendLine($"        /// <param name=\"{param.Name}\">The {param.Name} parameter.</param>");
            }

            sb.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token for the operation.</param>");
            sb.AppendLine($"        /// <returns>The result of the function call.</returns>");
            sb.AppendLine($"        [BamlFunction(\"{function.Name}\", \"{function.Client}\")]");

            var parameters = string.Join(", ", function.Parameters.Select(p =>
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));

            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";

            parameters += "CancellationToken cancellationToken = default";

            var signature = $"Task<{returnType}> {methodName}Async({parameters})";

            if (isImplementation)
            {
                sb.AppendLine($"        public async {signature}");
            }
            else
            {
                sb.AppendLine($"        {signature};");
            }
        }

        private void GenerateStreamingFunctionSignature(StringBuilder sb, BamlFunction function)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Streams the BAML function '{function.Name}'.");
            sb.AppendLine($"        /// </summary>");

            foreach (var param in function.Parameters)
            {
                sb.AppendLine($"        /// <param name=\"{param.Name}\">The {param.Name} parameter.</param>");
            }

            sb.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token for the operation.</param>");
            sb.AppendLine($"        /// <returns>An async enumerable of partial results.</returns>");

            var parameters = string.Join(", ", function.Parameters.Select(p =>
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));

            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";

            parameters += "CancellationToken cancellationToken = default";

            sb.AppendLine($"        IAsyncEnumerable<{returnType}> Stream{methodName}Async({parameters});");
            sb.AppendLine();
        }

        private void GenerateFunctionImplementation(StringBuilder sb, BamlFunction function)
        {
            GenerateFunctionSignature(sb, function, true);
            sb.AppendLine("        {");

            var parametersObject = "new { " + string.Join(", ", function.Parameters.Select(p => p.Name)) + " }";
            if (!function.Parameters.Any())
                parametersObject = "new { }";

            sb.AppendLine($"            return await Runtime.CallFunctionAsync<{MapBamlTypeToCSharp(function.ReturnType)}>(\"{function.Name}\", {parametersObject}, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateStreamingFunctionImplementation(StringBuilder sb, BamlFunction function)
        {
            var returnType = MapBamlTypeToCSharp(function.ReturnType);
            var methodName = ToPascalCase(function.Name);

            var parameters = string.Join(", ", function.Parameters.Select(p =>
                $"{MapBamlTypeToCSharp(p.Type)} {p.Name}"));

            if (!string.IsNullOrEmpty(parameters))
                parameters += ", ";

            parameters += "CancellationToken cancellationToken = default";

            sb.AppendLine($"        public IAsyncEnumerable<{returnType}> Stream{methodName}Async({parameters})");
            sb.AppendLine("        {");

            var parametersObject = "new { " + string.Join(", ", function.Parameters.Select(p => p.Name)) + " }";
            if (!function.Parameters.Any())
                parametersObject = "new { }";

            sb.AppendLine($"            return Runtime.StreamFunctionAsync<{returnType}>(\"{function.Name}\", {parametersObject}, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private string MapBamlTypeToCSharp(string bamlType)
        {
            // Handle array types
            if (bamlType.EndsWith("[]"))
            {
                var elementType = bamlType.Substring(0, bamlType.Length - 2);
                return $"IEnumerable<{MapBamlTypeToCSharp(elementType)}>";
            }

            // Handle union types (e.g., "StopTool | ReplyTool")
            if (bamlType.Contains("|"))
            {
                // For now, use object for union types
                // In a more sophisticated implementation, we could generate discriminated unions
                return "object";
            }

            // Map primitive types
            return bamlType.ToLowerInvariant() switch
            {
                "string" => "string",
                "int" => "int",
                "float" => "float",
                "double" => "double",
                "bool" => "bool",
                "boolean" => "bool",
                _ => bamlType // Assume it's a custom type
            };
        }

        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            return char.ToUpperInvariant(input[0]) + input.Substring(1);
        }


    }
}

